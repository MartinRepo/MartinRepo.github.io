<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>金融市场交易(COMP226) | Martin&#39;s space</title>
<meta name="keywords" content="Finance">
<meta name="description" content="R语言基础（W1） 基本数据类型 character(string) logical(boolean) numeric(number) factors(categories) factors表示分类，将分类数据存储为整数向量。下面用代码解释 # 创建一个性别的factor &gt; gender &lt;- fa">
<meta name="author" content="Martin">
<link rel="canonical" href="https://martinspace.top/zh/comp226/">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <meta name="referrer" content="no-referrer-when-downgrade">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc3e848411f8e2e3b39fd084e8d998d9f2d9782118c440525c90992eaecdc9f0.css" integrity="sha256-vD6EhBH44uOzn9CE6NmY2fLZeCEYxEBSXJCZLq7NyfA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://martinspace.top/img/icebear.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://martinspace.top/img/icebear.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://martinspace.top/img/icebear.jpg">
<link rel="apple-touch-icon" href="https://martinspace.top/icebear.jpg">
<link rel="mask-icon" href="https://martinspace.top/icebear.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://martinspace.top/zh/comp226/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css" />
<script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
          },
          svg: {
            fontCache: 'global'
          }
        };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J8TFFL1ZS7"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-J8TFFL1ZS7', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="金融市场交易(COMP226)" />
<meta property="og:description" content="R语言基础（W1） 基本数据类型 character(string) logical(boolean) numeric(number) factors(categories) factors表示分类，将分类数据存储为整数向量。下面用代码解释 # 创建一个性别的factor &gt; gender &lt;- fa" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://martinspace.top/zh/comp226/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-02-05T08:42:27+00:00" />
<meta property="article:modified_time" content="2023-02-05T08:42:27+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="金融市场交易(COMP226)"/>
<meta name="twitter:description" content="R语言基础（W1） 基本数据类型 character(string) logical(boolean) numeric(number) factors(categories) factors表示分类，将分类数据存储为整数向量。下面用代码解释 # 创建一个性别的factor &gt; gender &lt;- fa"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📒 文章",
      "item": "https://martinspace.top/zh/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "🎓 本科生涯",
      "item": "https://martinspace.top/zh/post/1liverpool/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "金融市场交易(COMP226)",
      "item": "https://martinspace.top/zh/comp226/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "金融市场交易(COMP226)",
  "name": "金融市场交易(COMP226)",
  "description": "R语言基础（W1） 基本数据类型 character(string) logical(boolean) numeric(number) factors(categories) factors表示分类，将分类数据存储为整数向量。下面用代码解释 # 创建一个性别的factor \u0026gt; gender \u0026lt;- fa",
  "keywords": [
    "Finance"
  ],
  "articleBody": "R语言基础（W1） 基本数据类型 character(string) logical(boolean) numeric(number) factors(categories) factors表示分类，将分类数据存储为整数向量。下面用代码解释\n# 创建一个性别的factor \u003e gender \u003c- factor(c(\"男\", \"女\", \"女\", \"男\", \"男\")) # 显示gender对象的水平(分类) \u003e levels(gender) [1] \"女\" \"男\" # 显示gender对象的摘要信息 \u003e summary(gender) 女 男 2 3 # 显示gender对象中每个水平的计数 \u003e table(gender) gender 女 男 2 3 is和as的区别 is.***()函数用于判断一个对象是否属于某个特定的类别，返回一个逻辑值。 as.***()函数则用于将一个对象转换为指定的类别，返回一个转换后的对象。 vector和list的区别 类型： vector是一种简单的数据结构，其中所有元素必须是相同的类型。 list是一种复杂的数据结构，其中每个元素可以是任意类型的对象。 长度： vector必须是一个固定长度，一旦创建就不能更改。 list的长度是可变的，可以随时添加或删除元素。 索引： vector中的元素可以使用整数索引来访问，例如x[1]表示访问x中的第一个元素。 list中的元素可以使用名称或位置索引来访问，例如x[[1]]表示访问x中的第一个元素，x[[\"name\"]]表示访问x中名称为\"name\"的元素。 函数 给一个函数，写法如下。显然，该函数是计算输入的平均值。\nmyMean \u003c- function(input=1:5) { sum \u003c- 0 for (x in input) sum \u003c- sum + x return(sum/length(input)) } 关于参数 以上面代码为例。我们可以置顶参数，例如这里的input=1:5。当然也可以不指定参数，不指定参数时（例如只输入input），这时会对不兼容的参数类型报错，例如vector。\n如果指定了参数，那么在传入参数时，可以使用默认也可以重写（如下面代码所示）。\n\u003e print(myMean()) # 传入默认的参数 [1] 3 \u003e print(myMean(1:10)) # 重写默认的参数 [1] 5.5 在函数中没有return语句？ 直接返回最后一个变量的赋值\n\u003e test1 \u003c- function(a=1) return(a) \u003e test3 \u003c- function(a=1) b \u003c- a \u003e test2 \u003c- function(a=1) a \u003e print(test1()); print(test2()); print(test3()) [1] 1 [1] 1 [1] 1 Matrices和Data.frames的区别 和vector还有list很相似\n类型 Matrix中所有元素的类型必须都相同 Data.frame中元素的类型可以不同。 索引 Matrix中的元素可以使用行列索引来访问，例如m[1,2]表示访问m中第1行第2列的元素。 Data.frame中的元素可以使用行列索引和列名称来访问，例如df[1,2]表示访问df中第1行第2列的元素，df$colname表示访问df中名为\"colname\"的列。 维度 Matrix是一个具有固定行列数的二维数组 data.frame可以拥有任意行数和列数。 Recycing R中挺有意思的性质\nRecycling 是指在进行二元运算时，如果其中一个运算对象长度不足，R 会自动将其进行“重复”直到和另一个对象长度相等。这样可以避免出现因为维度不匹配而导致的错误。\n举例说明 使用recycling创建一个vector 1 4 3 8 5 12 7 16 9 20\na\u003c-c(1,2)*1:11 下面表格说明一下👇\n1 2 3 4 5 6 7 8 9 10 11 (1,2) (1,2) (1,2) (1,2) (1,2) (1) 最终结果：1*1, 2*2, 3*1, 4*2 ……\nAPPLY family apply family可以说是循环的平替。在apply家族中，每一种函数都对一种数据结构进行操作\nlapply (lists/vectors) sapply (lapply的简化版本) apply (matrices/data.frames) mapply (multiple lists/vectors/matrices) \u003e lst \u003c- list(c(1,2,3), c(2,3,4), c(0,10)); \u003e lapply(lst, mean) [[1]] [1] 2 [[2]] [1] 3 [[3]] [1] 5 \u003e sapply(lst, mean) [1] 2 3 5 \u003e df Stock1 Stock2 Stock3 Day1 17.34 1.32 612 Day2 19.43 1.31 580 Day3 15.64 1.22 695 Day4 15.66 NA 690 # MARGIN=2 对列计算 \u003e apply(df, mean, MARGIN=2) Stock1 Stock2 Stock3 17.0175 NA 644.2500 # MARGIN=1 对行计算 \u003e apply(df, mean, MARGIN=1) Day1 Day2 Day3 Day4 210.2200 200.2467 237.2867 NA # MARGIN=c(1,2) 对行和列都计算 # mapply用法 mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE) mapply(rep, 1:3, 3:1) # equivilent to list(rep(1:3), rep(2:2), rep(3:1)) FUN 是要应用于向量的函数。 ... 是多个要操作的向量，它们可以是列表、矩阵或数据框，他们之间用逗号隔开。 MoreArgs 是一个可选的参数，表示传递给 FUN 的额外参数。 SIMPLIFY 表示是否要尝试将结果简化为向量或矩阵，默认为 TRUE。 USE.NAMES 表示是否使用结果的名称，默认为 TRUE。 mapply() 函数的作用是将函数 FUN 应用于多个向量的对应元素，然后返回一个向量或矩阵。它也会自动使用 recycling 特性，即如果两个或更多的向量长度不一致，则会将较短的向量复制多次以使它们的长度相等。\nFinanacial time series and quantmod 金融时间序列（Finanacial time series）是以时间为索引的测量序列。\n每隔一定时间 间隔不均匀时间 通俗来讲，Finanacial time series指金融市场中一系列基于时间序列的经济和金融变量的数据。这些变量通常包括股票价格、利率、货币汇率、商品价格、经济指标等等。\nquantmod包\n可以拿到每天的金融数据 绘制financial time series图表 # quantmod使用方法 library(quantmod) getSymbols(\"AAPL\") print(head(AAPL)) # first few rows of the data print(first(AAPL)) # first row print(last(AAPL)) # last row 这里拿出来的数据是xts（eXtensible Time Series）类型的，后面会提到。\nxts包\n在R中有很多时间的类型，POSIXct, POSIXlt, Date, chron, timeData, yearmon, yearqtr。这里主要使用Date(日期）和POSIXct（日期和时间）。\nR语言中有两种时间序列的包\nzoo（“Z’s ordered observations”）提供了一种用于处理缺失数据和不规则时间序列的框架。处理的数据必须类型统一 xts（“extensible time series”）是基于zoo的扩展包，提供了更多的功能和更高的性能，适用于高频时间序列数据。这意味着所有zoo函数都能作用于xts对象。 市场微观结构（W2-W3） 金融市场和自动交易 主要是一些名词需要熟悉一下 金融市场大致分为以下四种\nCapital markets (equities and fixed income) 资本市场 Foreign exchange markets 外汇市场 Money markets 货币市场 Derivative markets (e.g. futures and options) 衍生品市场 主动投资vs被动投资\n被动投资指跟踪市场（例如一个指数基金跟踪S\u0026P500（标普500）） 主动投资制作交易策略来打破被动投资的基准 股票市场 股份允许公司通过公共所有制为自己融资 股票代表公司固有价值或权益的一部分 一定时间内的股份数量的已知的 公司可以发行和回购股票或 定期向股东支付股息 在评估企业估值和交易策略时，企业的这些行为很重要 用adjusted prices来表示股票 在资本市场中，adjustment是指针对金融工具（如股票、债券或衍生品）的条款作出的更改，以响应市场情况或事件。这种变化可能影响该工具的价值、风险或到期时间。\n调整方式（Adjustment） Cash dividends，现金股利，从收盘价中扣除股息。 Stock dividends / stock splits，股票分红 / 股票分割 股票分红\n分红是公司利润的一部分，按照股东持有的股份比例，以现金或股票的形式向股东分配的。一般情况下，公司会定期向股东支付股息，以鼓励投资者持有股票。股票分红的大小和频率取决于公司的盈利情况、财务状况、管理层决策等因素。\n举例：某公司规定每持有一股在分红时会获得两股分红股份，因此原股票价格要除以3。例如分红前股价为25元，分红后每股为8.33元，这意味着股票持有者将获得2股分红股份/股。\n股票分割\n分割是指将一股股票分成若干股，比如将一股股票分割为两股、三股等等。分割之后，每一股的价格会降低，但是股东所持有的股票总数和股票市值不会改变。股票分割通常是为了让公司的股票更容易流通，以及吸引更多的投资者。股票分割的比例一般由公司决定，通常会在股价上涨的情况下进行。\n举例：某公司股票价格为25元，分割成两份后，每股变成12.5元。即股票持有者并没有获得额外收益。\n期货（Futures） 远期合约（forward）是一种协议，指在未来某一特定日期以某一价格买入或卖出某一固定数量的特定资产。\n期货合约（Futures contract）是一种具有标准化条款的远期合约。\nS\u0026P 500 E-mini Futures 标普500E-mini期货 FTSE 100 Futures 富时100期货 Crude Oil Futures 原油期货 Eurodollar futures 欧洲美元期货(利率期货) CME Euro FX Futures 芝加哥商品交易所欧元外汇期货 期货适用于广泛的基础资产（wide array of underlying assets）。\n期货合约\n期货合约的交易一般在期货交易所进行。在交易所上，买家和卖家通过经纪人或交易所直接交易合约。在合约到期日，双方需要履行合约义务，即按合约规定的价格买入或卖出商品。如果合约到期时仍未平仓，合约将会被强制执行。这给价差交易提供了交易机会。\nETF（Exchange-traded funds） ETF，中文翻译交易所的交易基金。也叫一篮子资产\n包括指数（index），商品（commodity），债券（bond），货币（concurrency）etf。\n交易角色\nDealers 用自己的账户买卖证券 Brokers 经纪人，为客户买卖证券 Broker-Dealers 经纪商，同时扮演以上两个角色（通常是投资银行） Limit Order Books 通常由公共交易所运营 Dark Pools 由经纪商或公共交易所运营 Limit order book market 这是指一种金融市场的交易方式，这个簿维护了市场中所有买家和卖家的订单，并且会在买卖双方的限价单价格相等时匹配这些订单。在这种市场中，交易员可以提交各种不同类型的订单，包括限价单、市价单等等。\n未匹配的限价订单存储在订单簿中（order book） 买盘存储在买盘簿中（bid book） 卖盘或询价/报价存储在询价簿中（ask book) Tick size和Bid spread\nTick size指的是股票价格在交易所报价时的最小变动单位。例如，如果一个股票的Tick size为0.01美元，那么这个股票的报价必须以0.01美元为单位递增或递减。较小的Tick size通常会提高股票市场的流动性，因为更多的价格水平可以被交易，从而提高市场的活跃度。\nBid spread是指买方的最高出价和卖方的最低要价之间的差距。较小的Bid spread通常是股票市场流动性较高的标志，因为交易者可以更容易地买入或卖出股票，而且交易成本更低。一个大的价差表明实际价格的不确定性。\n对于频繁交易的品种，bid spread通常等于tick size。\n做空（short selling or shorting）\n举个例子，张三现在想要做空某粮液的股票。他先向券商借了两万股，找准时机，在市场抛售这两万股股票。此举引起大量恐慌盘的抛售，股票价格应声下跌。之后张三找准时机，再偷偷买回之前抛售的2万股股票，并将其还给券商。他挣到的就是下跌过程中的价差。\n这里引入了多空的概念。多头就是看好股票的后市价值，因此引发的动作是买入。空头就是不看好这支股票的后市价值，选择卖掉股票，就叫卖空。\n限价单和市价单（Limit orders \u0026 market orders）\n限价单将买方或卖方的最大或最小价格限制在一个特定的范围内。如果市场价格达到或超过指定的价格水平，交易就会发生，否则订单将被保留在交易所的订单簿中，等待市场价格到达交易者指定的价格水平。 市价单则是以市场当前的价格来执行的订单类型。交易者不指定一个特定的价格，而是要求交易所以市场当前的最优价格来执行订单。市价单在交易所中立即执行，不管证券当前的价格是多少。 市价单中的slippage指订单在执行过程中出现的价格差异，即交易者预期得到的价格和实际成交价格之间的差异。 市价单的特点是以市场当前的最优价格来执行，但是市场价格变化较快，因此在订单提交和执行之间可能会出现价格波动，导致交易者的实际成交价格与预期的价格不同。这种价格差异就被称为slippage。 市场数据粒度\nk线图 tick数据（tick表示由于交易而导致的价格变化） Market Makers 在金融市场中，市场做市商（Market Maker）是一种为证券和衍生品提供流动性的交易者。他们通常是由投资银行、证券公司或专门的做市商公司提供服务的交易者。\n所以他们经常进行的是高频交易，反复买卖抓住价差。他们的存在会缩小价差，但是也有证据表明，在市场压力大的时候，高频交易者往往会放弃市场。算是有争议的一个角色了。\ntoxic order flow（有毒订单流）\nmarket maker面临的最重要的一个问题就是如何避免有毒订单流。\n有毒订单流指的是出于某些目的导致市场价格异常波动或产生重大冲击的交易订单流。这些订单流可能会给市场造成不稳定性和影响市场的公平性。\n市场做市商是为了提高市场的流动性和减少市场波动而存在的，他们通过在买卖价格之间提供报价来赚取利润，同时承担了买卖价差的风险。当有毒订单流出现时，市场的流动性和价格稳定性会受到影响，市场做市商需要承担更大的风险，因为有毒订单流可能导致市场价格剧烈波动，对市场做市商的盈利和风险管理造成不利影响。\nFront running \u0026 Dark pool Front running指交易员提前知道有大订单要来，于是价格提前被抬高，因为大家都往能挣钱的地方涌。\nLimit order就是front running\n如果交易员通过跳价（penny jump）来“front running”大额限价订单，会对市场做市商产生负面影响。如果市场做市商看到交易员跳价并且认为这可能是大额限价订单正在到来的信号，他们可能会相应地调整自己的报价，以适应订单执行后市场价格的变化。这样一来，市场做市商的报价将失去准确性，可能导致市场波动增大，从而影响交易者的投资决策。\n跳价（penny jump）：当买方想要购买大量的股票时，他们可能会放置一个大额限价单，这可能会影响到市场价格。因此，为了避免被其他交易者抢先执行，他们可能会将订单价格设定在略高于当前市场价格的水平，以确保他们的订单在市场价格上涨前先被执行。\n由于限价单人人都能看到，所以叫做light pool，与之对应的是dark pool。\n暗池（Dark Pool）指的是不公开交易数据的交易平台，这些平台允许投资者以匿名方式进行交易，同时也不公开交易价格和数量。这些平台通常由银行、投资机构和证券公司等机构创建，旨在为大型交易提供一种低风险、低成本的交易方式。\n与公开市场不同，暗池不会公开所有的订单信息，也不会立即公开交易结果，而是将这些信息保密并推迟披露。这使得交易者可以在不暴露他们的交易策略的情况下进行大额交易，而且交易也不会对市场价格产生影响。可以理解为暗池中的玩家有自己的规则，他们会以市场当前的价格作为参考，买卖双方不想让市场知道有大单子来或者有大单子走，就在暗池中以交易双方谈好的价格和数量进行交易。这也可能导致有些交易者无法了解整个市场的真实情况，进而影响他们的交易决策（通常指散户🤣）。\n算法交易者会大量利用暗池。\n执行算法 养老基金或其他大公司通常会进行大体量的交易，他们将这些交易任务交给代理。由于体量非常庞大，一下子全部进入市场会引起很大的价格波动。市价单会产生slippage，限价单会无法执行。因此，代理们会使用执行算法来分割大体量资金并增量执行，目的就是隐藏大订单的存在和最小化价格波动。\n执行算法的三种benchmarks\nVWAP - Volume-Weighted Average Price VWAP是指在一段时间内（通常为一天），基于成交量的加权平均价格，用于衡量一个证券的交易价格表现。 比如在某一天，一只股票上午9:00-11:30交易量是40，下午1:00-3:00交易量是10。那么假如我的执行算法要买入100股，就在第二天上午时间段买入100*(40/(40+10))，下午的时间段买入100*(10/(40+10)) 用订单的VWAP和市场的VWAP进行比较，至少达到市场的VWAP水准。 TWAP - Time-Weighted Average Price TWAP算法通过将指定的时间段分成若干个固定时间间隔，然后将交易平均分配在这些时间间隔中，以获得期间的平均价格。 计算方法：（两次交易之间的时间差*每次交易的价格）相加后/总的时间差 用订单的VWAP和市场的TWAP进行比较，至少达到市场的TWAP水准。 Implementation Shortfall 一种衡量交易执行质量的方法，用于评估交易策略的有效性。 比较交易成本和买入/卖出股票成本之间的差异 交易成本包括滑点成本、交易费用和市场影响成本等。 买入/卖出股票的成本可以通过VWAP或者TWAP等指标来计算。 IS的值表示交易策略的效果，如果IS值为正，表示交易策略产生了超额收益；如果IS值为负，则表示交易策略产生了亏损。 衡量交易策略的表现（W4-W5） 收益（Returns） 收益是判断profit-seeking交易策略的效果的基本要素。\n和执行算法（以最低成本执行预先定好的大订单）不同，profit-seeking交易策略目的是产生正的收益。\nsimple returns \u0026 logarithmic returns 假设P(t)和P(t-1)是连续观测的价格时间序列。\nsimple returns: R(t) = (P(t)-P(t-1))/P(t-1) = P(t)/P(t-1) - 1 log returns: R(t) = log(P(t)/P(t-1)) = logP(t) - logP(t-1) PS: 这里的log以e为底，是自然对数。为什么要有log收益？\n乘法变加法：对数收益将复利收益的乘法运算转换为加法运算，使计算变得更加简单。例如，如果我们有连续的对数收益率 r1、r2 和 r3，那么总收益率就是 r1 + r2 + r3，而不是复利收益的乘法运算。 对称性：对数收益率具有对称性，即正收益和负收益之间的比例关系保持不变。这使得对数收益更易于分析和比较，尤其是在计算投资组合的风险和收益时。 连续时间：在连续时间模型中，使用对数收益率更为方便。这是因为在连续时间中，收益率可以被看作是随时间连续变化的，而对数收益率的加法特性使得在这种情况下的计算更加简单。 数值稳定性：对数收益率提供了更好的数值稳定性。当收益率很小或者数据量很大时，使用对数收益率可以减少浮点数计算中的误差。 正态分布：在许多金融模型中，收益率被假设为正态分布。对数收益率的分布更接近于正态分布，因此在这些模型中更适用。 对于一个资产，我们可能会采取以下三种立场\nlong，做多（买入），因为我们期望价格走高。 flat，不买不卖，不确定。 short，做空（卖出），我们预测价格会走低。 当我们选择做空，买入时间在卖出时间之后。做空后两种收益比较\nlog return: 做空的log return = - 做多的log return simple return: 相对于多头的return，空头的return稍微复杂一些：$-R_t/(R_t+1)$ ROC函数 用TTR包中的ROC函数计算return\nROC函数的参数类型可以有两种\n对于简单收益，就是离散的（discerete） 对于log return，就是连续的（continuous） simple_ret \u003c- ROC(prices,type='discrete') log_ret \u003c- ROC(prices,type='continuous') Equity Curves 交易策略盈利能力的时间序列图。它代表了在特定时间内，投资组合价值的变化。equity curves是由投资组合的每个周期结束时的净值（即资产总值减去负债总值）计算得出的。\nPerfect Returns 这是通过perfect position计算出来的，当市场上升时做多，下降时做空\nCopycat strategy 我们几乎不可能拿到perfect return，没人会准确预测市场。Copycat strategy就是很粗暴的策略。如果当天收盘价\u003e当天开盘价，那么第二天就买入，否则第二天就卖出。\n这个策略很蠢，但什么时候会有用？\n价格连续很多天都朝一个方向移动。 当价格移动方向和前一天不同时，我们不会有太多损失。 测试这个策略\n使用utilities.R中的函数 getLogReturns(prices)从调整后的价格计算log return getEquityLog(log_ret,pos)从log return和位置向量上计算一个simple returns equity curve Risk reward measures 盈利能力的衡量标准与风险的衡量标准相结合的绩效衡量标准。\nSharpe Ratio Information Ratio Sortino Ratio Maximum drawdown Calmer Ratio 这些比率都在PerformanceAnalytics包中实现。\nMaximum drawdown最大回撤 描述的是投资组合在选定的时间段内可能遭受的最大损失，即从某个时间点的投资组合价值高点到随后的低点之间的资产价值的最大下降幅度。\n举个例子，如果你投资的股票在一段时间内从100元上升到200元，然后又降到50元，那么你的最大回撤就是（200-50）/200 = 75%。这说明在最差的情况下，你可能会损失掉75%的投资价值。\n最大回撤是一个非常有用的风险度量指标，因为它能够帮助投资者理解其投资组合在未来可能面临的最坏情况。然而，也要注意的是，最大回撤仅仅是过去的历史表现，并不能预测未来。另外，最大回撤也不应该单独使用，应该与其他风险和收益度量一起使用，以全面评估投资组合的性能。\nWealth Index财富指数 交易策略 (W6-W7) Moving averages 前面提到的copycat策略只是根据前一天的数据来决定第二天的买卖操作。而moving averages策略纳入了更多的历史数据来进行决策。\n时间序列过滤器\nlow-pass filter: 消除短期波动，留下趋势 high-pass filter: 消除趋势，留下短期波动 其中low和high代表的是频率\nCausal filters: 目的是在不引入未来信息（未来偏见）的情况下，从历史数据中提取有用的模式或信号。\n如果其output仅依赖于现在和过去的input，那么就是casual 如果其output依赖了未来的input，那么就是non-casual 在策略开发过程中，使用未来信息（在实际交易中是不可获取的）对策略产生不切实际的、过于乐观的效果。通过 Causal Filter，可以确保交易策略的有效性和实际可行性。\nSimple \u0026 Exponential moving average\nSimple: 它计算一段时间内（如5天、20天、50天等）数据的算术平均值。简单移动平均线可能受到异常值的影响，因此在处理数据时可能不够灵活。 Exponential: 这是一种加权移动平均线方法，它赋予最近的数据点更高的权重，但权重是按指数衰减的方式分配的。这意味着较早的数据点权重逐渐减小，但永远不会完全消失。指数移动平均线对于跟踪价格趋势非常有用，因为它能平滑短期波动，同时对长期趋势反应灵敏。 Bollinger Bands超买超卖策略 Bollinger Bands 是20世纪80年代开发的一种技术分析指标，用于研究金融市场的价格波动。布林带包含三条线，即中间线、上限线和下限线，它们可以帮助交易者识别市场的过度买入或过度卖出现象，从而指导交易决策。\n均值回归交易策略就使用了布林带\n当它们暗示市场超卖(oversold)时买入 当它们暗示市场超买(overbought)时卖出 布林带的三条线\n中间线（Middle Band）：通常为价格的简单移动平均（SMA），常见的周期设置为20天。 上限线（Upper Band）：上限线是中间线加上一个标准差乘以系数（通常为2）。标准差是一个统计概念，用于衡量数据的波动程度。这里的系数是用于调整带宽的一个参数，通常设为2。 下限线（Lower Band）：下限线是中间线减去一个标准差乘以系数（通常为2）。 布林带的宽度会随着价格波动的加大而加大，反之则缩小。布林带的宽度的变化可以用来衡量市场的波动性。当布林带变窄时，表示市场波动较小，可能预示着即将出现的大幅波动（突破）。当布林带变宽时，表示市场波动加大，可能暗示着趋势的持续。\n使用AAPL股票数据，应用布林带技术指标，并选择了2008年。图表的类型被设置为线形图（type=‘l’）。\n\u003e library(quantmod) \u003e getSymbols('AAPL') \u003e taString \u003c- 'addBBands();addBBands(draw=\"p\")' \u003e chartSeries(AAPL,TA=taString,subset='2008',type='l') 布林带的参数 bbands\u003c-BBands(prices, n=n, sd=sd)，其中n表示计算中轨线的周期为n天，sd表示上下轨道线相对于中轨线的标准差倍数为sd（不是标准差，是标准差的倍数！）。\nPath independence \u0026 dependence 如果一个交易策略不依赖过去的决策，那么这种决策被称为路径无关，path independence.\n布林带策略就是典型的路径无关交易策略\n路径无关实际上是一种很严格的限制，现在大部分的交易策略都是路径相关的。\n许多策略的构建都需要路径依赖，例如一些特殊的卖空条件：\nHolding period (持有时间) profit target (盈利目标) stop loss (止损点) Slippage 之前提到过，就是量很大没有单子能一下接的住，那么卖出的价格就会偏低（买入的价格会偏高）。这种情况通常在市场波动较大或流动性较低的情况下发生。在策略回测中，为了保守起见，我们通常假设滑点对交易者是不利的。\n在策略回测时采用这种假设滑点为负的标准方法是在策略回测中常用的一种方法。这样可以使回测结果更加保守，从而避免在实际交易中因对策略过于乐观而导致的损失。\n所以在构建交易模型时要估计实际成交价格与预期成交价格之间的差异，这叫做模拟滑点。\n交易策略的特点：了解策略在哪些市场环境中进行交易。如果其他市场参与者采取类似策略，滑点可能会变得更糟糕。例如： 如果在涨势中买入，可能会出现负滑点，因为许多交易者可能在涨势中买入，从而推高价格。 如果在抛售过程中买入，可能会出现正滑点，因为在供应过剩的情况下，你可能可以以较低的价格买入。 特定市场的特点：考虑你所交易的特定市场，因为不同市场的流动性和波动性可能会影响滑点。要考虑的一些因素包括： 被交易的资产：某些资产（如流动性较低的股票或加密货币）可能比流动性较强的资产（如主要货币对或大盘股）具有更高的滑点。 市场交易时间：在流动性较低的时段（例如，非正常交易时间）进行交易可能导致较高的滑点。 新闻与事件：重大新闻事件或经济数据发布可能导致波动性突然增加，从而导致滑点增加。 数据可用性：为了准确地模拟滑点，理想情况下需要访问高质量数据，包括： 订单簿数据：此类数据提供了不同价格和数量的信息，有助于更准确地估计滑点。 成交量数据：可以帮助了解市场的流动性状况，从而更好地预测滑点。 均值回归策略 2类策略\nmean reversion/contrarian/overbought-oversold 均值回归/反向/超买超卖 trend following / momentum 第一类策略是基于市场可能出现错误定价的观点。这些策略在实施时可能会有所不同。\n均值回归策略认为价格会在一段时间内回归到其长期平均值。 Contrarian策略是投资者相信市场可能对某些资产的价格作出错误判断，因此会采取与大多数人相反的交易行为。他们试图利用市场的过度反应来获得利润。 超买超卖策略则关注市场中的短期波动，试图捕捉价格在达到极端水平后可能出现的反转。 统计套利（Statistical Arbitrage） 这是一种复杂的量化投资策略，利用统计方法预测和利用金融市场的价格偏差。 基本思路是建立一个模型来识别价格偏离其预期值的情况，然后利用这种偏离进行交易，以期待价格回归预期值。 配对交易（Pairs Trading） 配对交易是统计套利的一种特殊形式。它基于两只或更多相关资产（通常是股票）之间的历史价格关系。 当这些资产的价格关系偏离历史正常水平时，交易员会买入价格偏低的资产并卖出价格偏高的资产，等待价格回归正常关系时再平仓，从而获得利润。 配对交易的难度在于找到正确的配对资产，需要对行业和公司有深入的理解，并且需要足够的数据来支持策略。 PS: 统计套利和配对交易都属于均值回归策略的一种，这些策略基于一个假设：市场价格或价格差（在配对交易中）会回归到它们的历史平均值。\n协整理论（Cointegration）\n用于描述两个或更多个时间序列之间的长期均衡关系。 在金融中，协整理论的应用主要体现在配对交易或其他统计套利策略中。如果两只股票的价格是协整的，那么他们的价格将保持一定的长期关系。如果这种关系暂时偏离了历史正常水平，那么交易员可以预期它会在未来回归到这种关系，并据此进行交易。 例如，如果股票A和股票B是协整的，并且A相对于B暂时过高，那么交易员可能会卖出A并买入B，等待价格回归到他们的长期关系。 隐式仓位比率（Implied Position Ratio）/对冲比率（Hedge Ratio）\n这个比率描述了需要用一个资产去对冲另一个资产风险的数量。 这种策略的关键在于，两个资产的价格变化是相关的。两个资产的价格变化也会在很短的时间内变得不再相关，所以要密切关注。 对冲比率通常通过回归分析来确定。 假设有两只股票，苹果（AAPL）和微软（MSFT），通过回归分析，我们发现每当苹果股价变动1美元，微软股价通常变动0.5美元，那么对冲比率就是0.5。这意味着，如果我们持有1美元的苹果股票，可以通过卖出0.5美元的微软股票来对冲我们的苹果股票风险。 在配对交易或统计套利策略中，投资者并不是因为预测到某一支股票会亏损才选择持有它，而是因为他们预测到两支股票之间的价格差距会收敛。 假设苹果（AAPL）和微软（MSFT）的股票价格有一定的相关性，而现在这两者的价格差距大于历史平均水平。也就是说，相对于微软，苹果的股票被低估了。在这种情况下，投资者可能会购买苹果股票，并同时卖空微软股票，希望当两者的价格差距回归到历史正常水平时获利。 在这个过程中，即使苹果的股票价格下跌，如果微软的股票价格下跌得更多（这是有可能的，因为两者的股票价格有相关性），那么投资者仍然有可能获利，因为他们是从两者的价格差距收敛中获利，而不是从单一股票的涨跌中获利。 上面的话使我对于对冲的理解更加深刻👆 spread通常指的是两个或更多相关资产之间的价格差异。根据资产的种类和交易的时间，spread可以在很多不同的情况下建立。以下是一些常见的例子：\n在同一个商品的不同月份之间。例如可以在3月份的原油期货和5月份的原油期货之间建立一个spread。这是一种常见的期货交易策略，投资者预期同一商品在不同交割月份的价格会有一定的变化。(called an interdelivery spread/ calendar spread) 在同一个或相关商品之间建立，通常是在同一个月份。例如，在黄金和白银之间建立一个spread。这种策略通常用于套利交易，投资者预期两种相关商品的价格差将回归到其历史平均水平。(intercommodity spread) 在在两个不同的交易所上交易的同一种或相关商品之间建立。例如，可以在纽约商品交易所交易的黄金期货和伦敦金属交易所交易的黄金期货之间建立一个spread。这种策略通常用于利用不同市场之间的价格差异进行套利。(Intermarket Spread) 在两只股票之间建立的，这两只股票通常是在同一行业或市场中，有相似的商业模式或经济影响因素。例如，可以在苹果（AAPL）和微软（MSFT）之间建立一个spread。这种策略通常用于利用两只股票价格的相对波动进行套利。(Pairs Trading) 第二类策略是基于资产价格行为的一种方式。\n趋势追踪策略是一种基于历史价格趋势预测未来价格趋势的策略。趋势追踪者认为市场价格展现出一定的动量或趋势，并会尝试利用这些趋势进行投资。当资产价格显现出上涨趋势时，趋势追踪者将买入该资产；当资产价格显现出下跌趋势时，趋势追踪者将卖出或做空该资产。 动量投资策略是一种基于资产近期价格表现预测未来价格表现的策略。动量投资者认为过去一段时间内表现较好的资产将在未来继续表现优秀，而表现较差的资产将在未来继续表现疲弱。因此，他们会购买近期表现优秀的资产，并卖出或做空近期表现疲弱的资产。 二者区别：这两种策略都是试图从市场趋势和动量中获利，但趋势追踪更注重长期趋势，而动量投资更注重短期价格表现。\n跟踪止损和盈利目标\n动量策略通常使用止损（Stop Loss）作为退出策略，而均值回归策略通常使用利润目标（Profit Target）作为退出策略。 Stop Loss：这是一种预先设定的订单，旨在限制投资者可能遭受的损失。这通常在价格向对投资者不利的方向移动时触发。在动量策略中，止损订单可以帮助投资者在市场反转时保护其资本。 Profit Target：这是预先设定的价格级别，一旦达到该级别，投资者将关闭位置以获取利润。在均值回归策略中，利润目标可以帮助投资者在价格回归到其均值时锁定利润。 Trailing Stop Loss：这是一种动态的止损策略。当交易价格向有利的方向移动时，跟踪止损将跟随市场价格移动，从而允许投资者在保护其资本的同时，捕获更多的利润。跟踪止损通常相对于交易的最佳价格而不是入场价格进行设置。 回溯测试，优化以及交叉验证(W7-W9) 交叉验证 想知道模型在未来交易中表现怎么样，要用到交叉验证。统计学中交叉验证的概念：把训练的模型一般化到不可见的数据集中表现怎么样。交叉验证降低了data-snooping bias（数据窥探风险）\nIn-sample和out-sample test in-sample就是训练集，out-sample就是测试集\n作用\n防止过拟合 评判在为未来表现的重要指标 注意：out-sample中性能下降是很正常的现象\nRSI strategy RSI(Relative strength Index)相对强度指数。这是TTR包中的一个标准的指标。这个指标返回一个0-100之间的值，值越高表明市场最近正在上涨趋势，反之亦然。\nBias Look-ahead Bias: 这种偏误发生在你的模型或策略使用了在实际情况下不可能在当前时点获取的信息。例如，假设你在模型中使用了明天的股价作为今天投资决策的依据，这就产生了向前偏误。 Survivorship Bias: 生存偏误发生在，当你的样本只包含“生存者”（即，成功或者持续存在的例子），而忽视了“非生存者”（即，失败或者已经不存在的例子）。例如，在股票市场研究中，如果你只研究当前仍在交易的公司，而忽视了已经破产或被收购的公司，那么你的研究就可能存在生存偏误。 Data-snooping Bias: 这种偏误出现在过度拟合过去的数据，试图找出符合这些数据的模式或策略，但这些模式或策略在未来可能并不适用。这种过度拟合可能导致过于乐观的策略性能预期。 Time period Bias: 这种偏误出现在，当策略的性能依赖于选择的特定时间段时。例如，如果你的策略在牛市中表现出色，但在熊市中表现不佳，那么你就可能过于依赖特定的时间段（例如，仅在牛市中）进行策略测试。 Confirmation Bias: 确认偏误是一种心理学现象，当人们倾向于寻找和关注那些符合自己预设观点的信息，而忽视或者低估那些与自己观点相悖的信息。在交易策略的开发中，如果你只关注那些支持你的策略的测试结果，而忽视了那些反对你的策略的结果，那么你可能就会陷入确认偏误。 交叉验证可以避免Data-snooping Bias。\n",
  "wordCount" : "13041",
  "inLanguage": "zh",
  "datePublished": "2023-02-05T08:42:27Z",
  "dateModified": "2023-02-05T08:42:27Z",
  "author":[{
    "@type": "Person",
    "name": "Martin"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://martinspace.top/zh/comp226/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Martin's space",
    "logo": {
      "@type": "ImageObject",
      "url": "https://martinspace.top/img/icebear.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<script async src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://martinspace.top/zh/" accesskey="h" title="Martin&#39;s space (Alt + H)">
                <img src="https://martinspace.top/icebear.jpg" alt="" aria-label="logo"
                    height="35">Martin&#39;s space</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://martinspace.top/en/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://martinspace.top/zh/" title="🏠 主页">
                    <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://martinspace.top/zh/archives/" title="📁 归档">
                    <span>📁 归档</span>
                </a>
            </li>
            <li>
                <a href="https://martinspace.top/zh/tags" title="🏷️ 标签">
                    <span>🏷️ 标签</span>
                </a>
            </li>
            <li>
                <a href="https://martinspace.top/zh/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://martinspace.top/zh/about" title="💭 关于">
                    <span>💭 关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://martinspace.top/zh/">主页</a>&nbsp;»&nbsp;<a href="https://martinspace.top/zh/post/">📒 文章</a>&nbsp;»&nbsp;<a href="https://martinspace.top/zh/post/1liverpool/">🎓 本科生涯</a></div>
    <h1 class="post-title">
      金融市场交易(COMP226)
    </h1>
    <div class="post-meta">










创建: 2023-02-05 | 更新: 2023-02-05 | 字数: 13041字 | 阅读时长: 27分钟 | 
作者:Martin&nbsp;|&nbsp;标签: &nbsp;
    <ul class="post-tags-meta">
        <a href="https://martinspace.top/zh/tags/finance/">Finance</a>
    </ul>


    
    </div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details >
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#r%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80w1" aria-label="R语言基础（W1）">R语言基础（W1）</a><ul>
                            
                    <li>
                        <a href="#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="基本数据类型">基本数据类型</a></li>
                    <li>
                        <a href="#is%e5%92%8cas%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="is和as的区别">is和as的区别</a></li>
                    <li>
                        <a href="#vector%e5%92%8clist%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="vector和list的区别">vector和list的区别</a></li>
                    <li>
                        <a href="#%e5%87%bd%e6%95%b0" aria-label="函数">函数</a></li>
                    <li>
                        <a href="#matrices%e5%92%8cdataframes%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="Matrices和Data.frames的区别">Matrices和Data.frames的区别</a></li>
                    <li>
                        <a href="#recycing" aria-label="Recycing">Recycing</a></li>
                    <li>
                        <a href="#apply-family" aria-label="APPLY family">APPLY family</a></li>
                    <li>
                        <a href="#finanacial-time-series-and-quantmod" aria-label="Finanacial time series and quantmod">Finanacial time series and quantmod</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%b8%82%e5%9c%ba%e5%be%ae%e8%a7%82%e7%bb%93%e6%9e%84w2-w3" aria-label="市场微观结构（W2-W3）">市场微观结构（W2-W3）</a><ul>
                            
                    <li>
                        <a href="#%e9%87%91%e8%9e%8d%e5%b8%82%e5%9c%ba%e5%92%8c%e8%87%aa%e5%8a%a8%e4%ba%a4%e6%98%93" aria-label="金融市场和自动交易">金融市场和自动交易</a></li>
                    <li>
                        <a href="#%e8%82%a1%e7%a5%a8%e5%b8%82%e5%9c%ba" aria-label="股票市场">股票市场</a></li>
                    <li>
                        <a href="#%e8%b0%83%e6%95%b4%e6%96%b9%e5%bc%8fadjustment" aria-label="调整方式（Adjustment）">调整方式（Adjustment）</a></li>
                    <li>
                        <a href="#%e6%9c%9f%e8%b4%a7futures" aria-label="期货（Futures）">期货（Futures）</a></li>
                    <li>
                        <a href="#etfexchange-traded-funds" aria-label="ETF（Exchange-traded funds）">ETF（Exchange-traded funds）</a></li>
                    <li>
                        <a href="#limit-order-book-market" aria-label="Limit order book market">Limit order book market</a></li>
                    <li>
                        <a href="#market-makers" aria-label="Market Makers">Market Makers</a></li>
                    <li>
                        <a href="#front-running--dark-pool" aria-label="Front running &amp;amp; Dark pool">Front running &amp; Dark pool</a></li>
                    <li>
                        <a href="#%e6%89%a7%e8%a1%8c%e7%ae%97%e6%b3%95" aria-label="执行算法">执行算法</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e8%a1%a1%e9%87%8f%e4%ba%a4%e6%98%93%e7%ad%96%e7%95%a5%e7%9a%84%e8%a1%a8%e7%8e%b0w4-w5" aria-label="衡量交易策略的表现（W4-W5）">衡量交易策略的表现（W4-W5）</a><ul>
                            
                    <li>
                        <a href="#%e6%94%b6%e7%9b%8areturns" aria-label="收益（Returns）">收益（Returns）</a><ul>
                            
                    <li>
                        <a href="#simple-returns--logarithmic-returns" aria-label="simple returns &amp;amp; logarithmic returns">simple returns &amp; logarithmic returns</a></li>
                    <li>
                        <a href="#roc%e5%87%bd%e6%95%b0" aria-label="ROC函数">ROC函数</a></li></ul>
                    </li>
                    <li>
                        <a href="#equity-curves" aria-label="Equity Curves">Equity Curves</a></li>
                    <li>
                        <a href="#perfect-returns" aria-label="Perfect Returns">Perfect Returns</a></li>
                    <li>
                        <a href="#copycat-strategy" aria-label="Copycat strategy">Copycat strategy</a></li>
                    <li>
                        <a href="#risk-reward-measures" aria-label="Risk reward measures">Risk reward measures</a></li>
                    <li>
                        <a href="#maximum-drawdown%e6%9c%80%e5%a4%a7%e5%9b%9e%e6%92%a4" aria-label="Maximum drawdown最大回撤">Maximum drawdown最大回撤</a></li>
                    <li>
                        <a href="#wealth-index%e8%b4%a2%e5%af%8c%e6%8c%87%e6%95%b0" aria-label="Wealth Index财富指数">Wealth Index财富指数</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%ba%a4%e6%98%93%e7%ad%96%e7%95%a5-w6-w7" aria-label="交易策略 (W6-W7)">交易策略 (W6-W7)</a><ul>
                            
                    <li>
                        <a href="#moving-averages" aria-label="Moving averages">Moving averages</a></li>
                    <li>
                        <a href="#bollinger-bands%e8%b6%85%e4%b9%b0%e8%b6%85%e5%8d%96%e7%ad%96%e7%95%a5" aria-label="Bollinger Bands超买超卖策略">Bollinger Bands超买超卖策略</a></li>
                    <li>
                        <a href="#path-independence--dependence" aria-label="Path independence &amp;amp; dependence">Path independence &amp; dependence</a></li>
                    <li>
                        <a href="#slippage" aria-label="Slippage">Slippage</a></li>
                    <li>
                        <a href="#%e5%9d%87%e5%80%bc%e5%9b%9e%e5%bd%92%e7%ad%96%e7%95%a5" aria-label="均值回归策略">均值回归策略</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%9b%9e%e6%ba%af%e6%b5%8b%e8%af%95%e4%bc%98%e5%8c%96%e4%bb%a5%e5%8f%8a%e4%ba%a4%e5%8f%89%e9%aa%8c%e8%af%81w7-w9" aria-label="回溯测试，优化以及交叉验证(W7-W9)">回溯测试，优化以及交叉验证(W7-W9)</a><ul>
                            
                    <li>
                        <a href="#%e4%ba%a4%e5%8f%89%e9%aa%8c%e8%af%81" aria-label="交叉验证">交叉验证</a><ul>
                            
                    <li>
                        <a href="#in-sample%e5%92%8cout-sample-test" aria-label="In-sample和out-sample test">In-sample和out-sample test</a></li>
                    <li>
                        <a href="#rsi-strategy" aria-label="RSI strategy">RSI strategy</a></li>
                    <li>
                        <a href="#bias" aria-label="Bias">Bias</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h1 id="r语言基础w1">R语言基础（W1）<a hidden class="anchor" aria-hidden="true" href="#r语言基础w1">#</a></h1>
<h2 id="基本数据类型">基本数据类型<a hidden class="anchor" aria-hidden="true" href="#基本数据类型">#</a></h2>
<ul>
<li>character(string)</li>
<li>logical(boolean)</li>
<li>numeric(number)</li>
<li>factors(categories)</li>
</ul>
<p>factors表示分类，将分类数据存储为整数向量。下面用代码解释</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-R" data-lang="R"><span style="display:flex;"><span><span style="color:#007f7f"># 创建一个性别的factor</span>
</span></span><span style="display:flex;"><span>&gt; gender &lt;- factor(c(<span style="color:#0ff;font-weight:bold">&#34;男&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;女&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;女&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;男&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;男&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 显示gender对象的水平(分类)</span>
</span></span><span style="display:flex;"><span>&gt; levels(gender)
</span></span><span style="display:flex;"><span>[1] <span style="color:#0ff;font-weight:bold">&#34;女&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;男&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 显示gender对象的摘要信息</span>
</span></span><span style="display:flex;"><span>&gt; summary(gender)
</span></span><span style="display:flex;"><span>女 男 
</span></span><span style="display:flex;"><span> <span style="color:#ff0;font-weight:bold">2</span>  <span style="color:#ff0;font-weight:bold">3</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 显示gender对象中每个水平的计数</span>
</span></span><span style="display:flex;"><span>&gt; table(gender)
</span></span><span style="display:flex;"><span>gender
</span></span><span style="display:flex;"><span>女 男 
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">2</span> <span style="color:#ff0;font-weight:bold">3</span> 
</span></span></code></pre></div><h2 id="is和as的区别">is和as的区别<a hidden class="anchor" aria-hidden="true" href="#is和as的区别">#</a></h2>
<ul>
<li><code>is.***()</code>函数用于判断一个对象是否属于某个特定的类别，返回一个逻辑值。</li>
<li><code>as.***()</code>函数则用于将一个对象转换为指定的类别，返回一个转换后的对象。</li>
</ul>
<h2 id="vector和list的区别">vector和list的区别<a hidden class="anchor" aria-hidden="true" href="#vector和list的区别">#</a></h2>
<ul>
<li>类型：
<ul>
<li>vector是一种简单的数据结构，其中所有元素必须是相同的类型。</li>
<li>list是一种复杂的数据结构，其中每个元素可以是任意类型的对象。</li>
</ul>
</li>
<li>长度：
<ul>
<li>vector必须是一个固定长度，一旦创建就不能更改。</li>
<li>list的长度是可变的，可以随时添加或删除元素。</li>
</ul>
</li>
<li>索引：
<ul>
<li>vector中的元素可以使用整数索引来访问，例如<code>x[1]</code>表示访问<code>x</code>中的第一个元素。</li>
<li>list中的元素可以使用名称或位置索引来访问，例如<code>x[[1]]</code>表示访问<code>x</code>中的第一个元素，<code>x[[&quot;name&quot;]]</code>表示访问<code>x</code>中名称为<code>&quot;name&quot;</code>的元素。</li>
</ul>
</li>
</ul>
<h2 id="函数">函数<a hidden class="anchor" aria-hidden="true" href="#函数">#</a></h2>
<p>给一个函数，写法如下。显然，该函数是计算输入的平均值。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-R" data-lang="R"><span style="display:flex;"><span>myMean &lt;- <span style="color:#fff;font-weight:bold">function</span>(input=<span style="color:#ff0;font-weight:bold">1</span>:<span style="color:#ff0;font-weight:bold">5</span>) {
</span></span><span style="display:flex;"><span>    sum &lt;- <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (x <span style="color:#fff;font-weight:bold">in</span> input)
</span></span><span style="display:flex;"><span>        sum &lt;- sum + x
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span>(sum/length(input))
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p><strong>关于参数</strong>
以上面代码为例。我们可以置顶参数，例如这里的<code>input=1:5</code>。当然也可以不指定参数，不指定参数时（例如只输入input），这时会对不兼容的参数类型报错，例如vector。</p>
<p>如果指定了参数，那么在传入参数时，可以使用默认也可以重写（如下面代码所示）。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-R" data-lang="R"><span style="display:flex;"><span>&gt; print(myMean()) <span style="color:#007f7f"># 传入默认的参数</span>
</span></span><span style="display:flex;"><span>[1] <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; print(myMean(<span style="color:#ff0;font-weight:bold">1</span>:<span style="color:#ff0;font-weight:bold">10</span>)) <span style="color:#007f7f"># 重写默认的参数</span>
</span></span><span style="display:flex;"><span>[1] <span style="color:#ff0;font-weight:bold">5.5</span>
</span></span></code></pre></div><p><strong>在函数中没有return语句？</strong>
直接返回最后一个变量的赋值</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-R" data-lang="R"><span style="display:flex;"><span>&gt; test1 &lt;- <span style="color:#fff;font-weight:bold">function</span>(a=<span style="color:#ff0;font-weight:bold">1</span>) <span style="color:#fff;font-weight:bold">return</span>(a)
</span></span><span style="display:flex;"><span>&gt; test3 &lt;- <span style="color:#fff;font-weight:bold">function</span>(a=<span style="color:#ff0;font-weight:bold">1</span>) b &lt;- a
</span></span><span style="display:flex;"><span>&gt; test2 &lt;- <span style="color:#fff;font-weight:bold">function</span>(a=<span style="color:#ff0;font-weight:bold">1</span>) a
</span></span><span style="display:flex;"><span>&gt; print(test1()); print(test2()); print(test3())
</span></span><span style="display:flex;"><span>[1] <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>[1] <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>[1] <span style="color:#ff0;font-weight:bold">1</span>
</span></span></code></pre></div><h2 id="matrices和dataframes的区别">Matrices和Data.frames的区别<a hidden class="anchor" aria-hidden="true" href="#matrices和dataframes的区别">#</a></h2>
<p>和vector还有list很相似</p>
<ul>
<li>类型
<ul>
<li>Matrix中所有元素的类型必须都相同</li>
<li>Data.frame中元素的类型可以不同。</li>
</ul>
</li>
<li>索引
<ul>
<li>Matrix中的元素可以使用行列索引来访问，例如m[1,2]表示访问m中第1行第2列的元素。</li>
<li>Data.frame中的元素可以使用行列索引和列名称来访问，例如df[1,2]表示访问df中第1行第2列的元素，<code>df$colname</code>表示访问df中名为&quot;colname&quot;的列。</li>
</ul>
</li>
<li>维度
<ul>
<li>Matrix是一个具有固定行列数的二维数组</li>
<li>data.frame可以拥有任意行数和列数。</li>
</ul>
</li>
</ul>
<h2 id="recycing">Recycing<a hidden class="anchor" aria-hidden="true" href="#recycing">#</a></h2>
<p>R中挺有意思的性质</p>
<p>Recycling 是指在进行二元运算时，如果其中一个运算对象长度不足，R 会自动将其进行“重复”直到和另一个对象长度相等。这样可以避免出现因为维度不匹配而导致的错误。</p>
<p>举例说明
使用recycling创建一个vector 1 4 3 8 5 12 7 16 9 20</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-R" data-lang="R"><span style="display:flex;"><span>a&lt;-c(<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">2</span>)*<span style="color:#ff0;font-weight:bold">1</span>:<span style="color:#ff0;font-weight:bold">11</span>
</span></span></code></pre></div><p>下面表格说明一下👇</p>
<table>
<thead>
<tr>
<th>1 2</th>
<th>3 4</th>
<th>5 6</th>
<th>7 8</th>
<th>9 10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1,2)</td>
<td>(1,2)</td>
<td>(1,2)</td>
<td>(1,2)</td>
<td>(1,2)</td>
<td>(1)</td>
</tr>
</tbody>
</table>
<p>最终结果：1*1, 2*2, 3*1, 4*2 &hellip;&hellip;</p>
<h2 id="apply-family">APPLY family<a hidden class="anchor" aria-hidden="true" href="#apply-family">#</a></h2>
<p>apply family可以说是循环的平替。在apply家族中，每一种函数都对一种数据结构进行操作</p>
<ul>
<li>lapply (lists/vectors)</li>
<li>sapply (lapply的简化版本)</li>
<li>apply (matrices/data.frames)</li>
<li>mapply (multiple lists/vectors/matrices)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-R" data-lang="R"><span style="display:flex;"><span>&gt; lst &lt;- list(c(<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>), c(<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>,<span style="color:#ff0;font-weight:bold">4</span>), c(<span style="color:#ff0;font-weight:bold">0</span>,<span style="color:#ff0;font-weight:bold">10</span>));
</span></span><span style="display:flex;"><span>&gt; lapply(lst, mean)
</span></span><span style="display:flex;"><span>[[1]]
</span></span><span style="display:flex;"><span>[1] <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>[[2]]
</span></span><span style="display:flex;"><span>[1] <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>[[3]]
</span></span><span style="display:flex;"><span>[1] <span style="color:#ff0;font-weight:bold">5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; sapply(lst, mean)
</span></span><span style="display:flex;"><span>[1] <span style="color:#ff0;font-weight:bold">2</span> <span style="color:#ff0;font-weight:bold">3</span> <span style="color:#ff0;font-weight:bold">5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; df
</span></span><span style="display:flex;"><span>     Stock1 Stock2 Stock3
</span></span><span style="display:flex;"><span>Day1  <span style="color:#ff0;font-weight:bold">17.34</span>   <span style="color:#ff0;font-weight:bold">1.32</span>    <span style="color:#ff0;font-weight:bold">612</span>
</span></span><span style="display:flex;"><span>Day2  <span style="color:#ff0;font-weight:bold">19.43</span>   <span style="color:#ff0;font-weight:bold">1.31</span>    <span style="color:#ff0;font-weight:bold">580</span>
</span></span><span style="display:flex;"><span>Day3  <span style="color:#ff0;font-weight:bold">15.64</span>   <span style="color:#ff0;font-weight:bold">1.22</span>    <span style="color:#ff0;font-weight:bold">695</span>
</span></span><span style="display:flex;"><span>Day4  <span style="color:#ff0;font-weight:bold">15.66</span>     <span style="color:#fff;font-weight:bold">NA</span>    <span style="color:#ff0;font-weight:bold">690</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># MARGIN=2 对列计算</span>
</span></span><span style="display:flex;"><span>&gt; apply(df, mean, MARGIN=<span style="color:#ff0;font-weight:bold">2</span>)
</span></span><span style="display:flex;"><span> Stock1   Stock2   Stock3
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">17.0175</span>       <span style="color:#fff;font-weight:bold">NA</span> <span style="color:#ff0;font-weight:bold">644.2500</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># MARGIN=1 对行计算</span>
</span></span><span style="display:flex;"><span>&gt; apply(df, mean, MARGIN=<span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>    Day1     Day2     Day3     Day4 
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">210.2200</span> <span style="color:#ff0;font-weight:bold">200.2467</span> <span style="color:#ff0;font-weight:bold">237.2867</span>       <span style="color:#fff;font-weight:bold">NA</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># MARGIN=c(1,2) 对行和列都计算</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># mapply用法</span>
</span></span><span style="display:flex;"><span>mapply(FUN, <span style="color:#fff;font-weight:bold">...</span>, MoreArgs = <span style="color:#fff;font-weight:bold">NULL</span>, SIMPLIFY = <span style="color:#fff;font-weight:bold">TRUE</span>, USE.NAMES = <span style="color:#fff;font-weight:bold">TRUE</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mapply(rep, <span style="color:#ff0;font-weight:bold">1</span>:<span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">3</span>:<span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># equivilent to</span>
</span></span><span style="display:flex;"><span>list(rep(<span style="color:#ff0;font-weight:bold">1</span>:<span style="color:#ff0;font-weight:bold">3</span>), rep(<span style="color:#ff0;font-weight:bold">2</span>:<span style="color:#ff0;font-weight:bold">2</span>), rep(<span style="color:#ff0;font-weight:bold">3</span>:<span style="color:#ff0;font-weight:bold">1</span>))
</span></span></code></pre></div><ul>
<li><code>FUN</code> 是要应用于向量的函数。</li>
<li><code>...</code> 是多个要操作的向量，它们可以是列表、矩阵或数据框，他们之间用逗号隔开。</li>
<li><code>MoreArgs</code> 是一个可选的参数，表示传递给 <code>FUN</code> 的额外参数。</li>
<li><code>SIMPLIFY</code> 表示是否要尝试将结果简化为向量或矩阵，默认为 <code>TRUE</code>。</li>
<li><code>USE.NAMES</code> 表示是否使用结果的名称，默认为 <code>TRUE</code>。</li>
</ul>
<p>mapply() 函数的作用是将函数 FUN 应用于多个向量的对应元素，然后返回一个向量或矩阵。它也会自动使用 recycling 特性，即如果两个或更多的向量长度不一致，则会将较短的向量复制多次以使它们的长度相等。</p>
<h2 id="finanacial-time-series-and-quantmod">Finanacial time series and quantmod<a hidden class="anchor" aria-hidden="true" href="#finanacial-time-series-and-quantmod">#</a></h2>
<p>金融时间序列（Finanacial time series）是以时间为索引的测量序列。</p>
<ul>
<li>每隔一定时间</li>
<li>间隔不均匀时间</li>
</ul>
<p>通俗来讲，Finanacial time series指金融市场中一系列基于时间序列的经济和金融变量的数据。这些变量通常包括股票价格、利率、货币汇率、商品价格、经济指标等等。</p>
<p><strong>quantmod包</strong></p>
<ul>
<li>可以拿到每天的金融数据</li>
<li>绘制financial time series图表</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-R" data-lang="R"><span style="display:flex;"><span><span style="color:#007f7f"># quantmod使用方法</span>
</span></span><span style="display:flex;"><span>library(quantmod)
</span></span><span style="display:flex;"><span>getSymbols(<span style="color:#0ff;font-weight:bold">&#34;AAPL&#34;</span>)
</span></span><span style="display:flex;"><span>print(head(AAPL)) <span style="color:#007f7f"># first few rows of the data </span>
</span></span><span style="display:flex;"><span>print(first(AAPL)) <span style="color:#007f7f"># first row</span>
</span></span><span style="display:flex;"><span>print(last(AAPL)) <span style="color:#007f7f"># last row</span>
</span></span></code></pre></div><p>这里拿出来的数据是xts（eXtensible Time Series）类型的，后面会提到。</p>
<p><strong>xts包</strong></p>
<p>在R中有很多时间的类型，POSIXct, POSIXlt, Date, chron, timeData, yearmon, yearqtr。这里主要使用Date(日期）和POSIXct（日期和时间）。</p>
<p>R语言中有两种时间序列的包</p>
<ul>
<li>zoo（“Z’s ordered observations”）提供了一种用于处理缺失数据和不规则时间序列的框架。处理的数据必须类型统一</li>
<li>xts（“extensible time series”）是基于zoo的扩展包，提供了更多的功能和更高的性能，适用于高频时间序列数据。这意味着所有zoo函数都能作用于xts对象。</li>
</ul>
<h1 id="市场微观结构w2-w3">市场微观结构（W2-W3）<a hidden class="anchor" aria-hidden="true" href="#市场微观结构w2-w3">#</a></h1>
<h2 id="金融市场和自动交易">金融市场和自动交易<a hidden class="anchor" aria-hidden="true" href="#金融市场和自动交易">#</a></h2>
<p>主要是一些名词需要熟悉一下
金融市场大致分为以下四种</p>
<ul>
<li>Capital markets (equities and fixed income) 资本市场</li>
<li>Foreign exchange markets 外汇市场</li>
<li>Money markets 货币市场</li>
<li>Derivative markets (e.g. futures and options) 衍生品市场</li>
</ul>
<p><strong>主动投资vs被动投资</strong></p>
<ul>
<li>被动投资指跟踪市场（例如一个指数基金跟踪S&amp;P500（标普500））</li>
<li>主动投资制作交易策略来打破被动投资的基准</li>
</ul>
<h2 id="股票市场">股票市场<a hidden class="anchor" aria-hidden="true" href="#股票市场">#</a></h2>
<ul>
<li>股份允许公司通过公共所有制为自己融资</li>
<li>股票代表公司固有价值或权益的一部分</li>
<li>一定时间内的股份数量的已知的
<ul>
<li>公司可以发行和回购股票或</li>
<li>定期向股东支付股息</li>
</ul>
</li>
<li>在评估企业估值和交易策略时，企业的这些行为很重要</li>
<li>用adjusted prices来表示股票</li>
</ul>
<p>在资本市场中，adjustment是指针对金融工具（如股票、债券或衍生品）的条款作出的更改，以响应市场情况或事件。这种变化可能影响该工具的价值、风险或到期时间。</p>
<h2 id="调整方式adjustment">调整方式（Adjustment）<a hidden class="anchor" aria-hidden="true" href="#调整方式adjustment">#</a></h2>
<ul>
<li>Cash dividends，现金股利，从收盘价中扣除股息。</li>
<li>Stock  dividends / stock  splits，股票分红 / 股票分割</li>
</ul>
<p><strong>股票分红</strong></p>
<p>分红是公司利润的一部分，按照股东持有的股份比例，以现金或股票的形式向股东分配的。一般情况下，公司会定期向股东支付股息，以鼓励投资者持有股票。股票分红的大小和频率取决于公司的盈利情况、财务状况、管理层决策等因素。</p>
<p>举例：某公司规定每持有一股在分红时会获得两股分红股份，因此原股票价格要除以3。例如分红前股价为25元，分红后每股为8.33元，这意味着股票持有者将获得2股分红股份/股。</p>
<p><strong>股票分割</strong></p>
<p>分割是指将一股股票分成若干股，比如将一股股票分割为两股、三股等等。分割之后，每一股的价格会降低，但是股东所持有的股票总数和股票市值不会改变。股票分割通常是为了让公司的股票更容易流通，以及吸引更多的投资者。股票分割的比例一般由公司决定，通常会在股价上涨的情况下进行。</p>
<p>举例：某公司股票价格为25元，分割成两份后，每股变成12.5元。即股票持有者并没有获得额外收益。</p>
<h2 id="期货futures">期货（Futures）<a hidden class="anchor" aria-hidden="true" href="#期货futures">#</a></h2>
<p>远期合约（forward）是一种协议，指在未来某一特定日期以某一价格买入或卖出某一固定数量的特定资产。</p>
<p>期货合约（Futures contract）是一种具有标准化条款的远期合约。</p>
<ul>
<li>S&amp;P 500 E-mini Futures 标普500E-mini期货</li>
<li>FTSE 100 Futures 富时100期货</li>
<li>Crude Oil Futures 原油期货</li>
<li>Eurodollar futures 欧洲美元期货(利率期货)</li>
<li>CME Euro FX Futures 芝加哥商品交易所欧元外汇期货</li>
</ul>
<p>期货适用于广泛的基础资产（wide array of underlying assets）。</p>
<p><strong>期货合约</strong></p>
<p>期货合约的交易一般在期货交易所进行。在交易所上，买家和卖家通过经纪人或交易所直接交易合约。在合约到期日，双方需要履行合约义务，即按合约规定的价格买入或卖出商品。如果合约到期时仍未平仓，合约将会被强制执行。这给价差交易提供了交易机会。</p>
<h2 id="etfexchange-traded-funds">ETF（Exchange-traded funds）<a hidden class="anchor" aria-hidden="true" href="#etfexchange-traded-funds">#</a></h2>
<p>ETF，中文翻译交易所的交易基金。也叫一篮子资产</p>
<p>包括指数（index），商品（commodity），债券（bond），货币（concurrency）etf。</p>
<p>交易角色</p>
<ul>
<li>Dealers 用自己的账户买卖证券</li>
<li>Brokers 经纪人，为客户买卖证券</li>
<li>Broker-Dealers 经纪商，同时扮演以上两个角色（通常是投资银行）</li>
<li>Limit Order Books 通常由公共交易所运营</li>
<li>Dark Pools 由经纪商或公共交易所运营</li>
</ul>
<h2 id="limit-order-book-market">Limit order book market<a hidden class="anchor" aria-hidden="true" href="#limit-order-book-market">#</a></h2>
<p>这是指一种金融市场的交易方式，这个簿维护了市场中所有买家和卖家的订单，并且会在买卖双方的限价单价格相等时匹配这些订单。在这种市场中，交易员可以提交各种不同类型的订单，包括限价单、市价单等等。</p>
<ul>
<li>未匹配的限价订单存储在订单簿中（order book）</li>
<li>买盘存储在买盘簿中（bid book）</li>
<li>卖盘或询价/报价存储在询价簿中（ask book)</li>
</ul>
<p><strong>Tick size和Bid spread</strong></p>
<p>Tick size指的是股票价格在交易所报价时的最小变动单位。例如，如果一个股票的Tick size为0.01美元，那么这个股票的报价必须以0.01美元为单位递增或递减。较小的Tick size通常会提高股票市场的流动性，因为更多的价格水平可以被交易，从而提高市场的活跃度。</p>
<p>Bid spread是指买方的最高出价和卖方的最低要价之间的差距。较小的Bid spread通常是股票市场流动性较高的标志，因为交易者可以更容易地买入或卖出股票，而且交易成本更低。一个大的价差表明实际价格的不确定性。</p>
<p>对于频繁交易的品种，bid spread通常等于tick size。</p>
<p><strong>做空（short selling or shorting）</strong></p>
<p>举个例子，张三现在想要做空某粮液的股票。他先向券商借了两万股，找准时机，在市场抛售这两万股股票。此举引起大量恐慌盘的抛售，股票价格应声下跌。之后张三找准时机，再偷偷买回之前抛售的2万股股票，并将其还给券商。他挣到的就是下跌过程中的价差。</p>
<p>这里引入了多空的概念。多头就是看好股票的后市价值，因此引发的动作是买入。空头就是不看好这支股票的后市价值，选择卖掉股票，就叫卖空。</p>
<p><strong>限价单和市价单（Limit orders &amp; market orders）</strong></p>
<ul>
<li>限价单将买方或卖方的最大或最小价格限制在一个特定的范围内。如果市场价格达到或超过指定的价格水平，交易就会发生，否则订单将被保留在交易所的订单簿中，等待市场价格到达交易者指定的价格水平。</li>
<li>市价单则是以市场当前的价格来执行的订单类型。交易者不指定一个特定的价格，而是要求交易所以市场当前的最优价格来执行订单。市价单在交易所中立即执行，不管证券当前的价格是多少。</li>
<li>市价单中的slippage指订单在执行过程中出现的价格差异，即交易者预期得到的价格和实际成交价格之间的差异。</li>
<li>市价单的特点是以市场当前的最优价格来执行，但是市场价格变化较快，因此在订单提交和执行之间可能会出现价格波动，导致交易者的实际成交价格与预期的价格不同。这种价格差异就被称为slippage。</li>
</ul>
<p><strong>市场数据粒度</strong></p>
<ul>
<li>k线图</li>
<li>tick数据（tick表示由于交易而导致的价格变化）</li>
</ul>
<h2 id="market-makers">Market Makers<a hidden class="anchor" aria-hidden="true" href="#market-makers">#</a></h2>
<p>在金融市场中，市场做市商（Market Maker）是一种为证券和衍生品提供流动性的交易者。他们通常是由投资银行、证券公司或专门的做市商公司提供服务的交易者。</p>
<p>所以他们经常进行的是高频交易，反复买卖抓住价差。他们的存在会缩小价差，但是也有证据表明，在市场压力大的时候，高频交易者往往会放弃市场。算是有争议的一个角色了。</p>
<p><strong>toxic order flow（有毒订单流）</strong></p>
<p>market maker面临的最重要的一个问题就是如何避免有毒订单流。</p>
<p>有毒订单流指的是出于某些目的导致市场价格异常波动或产生重大冲击的交易订单流。这些订单流可能会给市场造成不稳定性和影响市场的公平性。</p>
<p>市场做市商是为了提高市场的流动性和减少市场波动而存在的，他们通过在买卖价格之间提供报价来赚取利润，同时承担了买卖价差的风险。当有毒订单流出现时，市场的流动性和价格稳定性会受到影响，市场做市商需要承担更大的风险，因为有毒订单流可能导致市场价格剧烈波动，对市场做市商的盈利和风险管理造成不利影响。</p>
<h2 id="front-running--dark-pool">Front running &amp; Dark pool<a hidden class="anchor" aria-hidden="true" href="#front-running--dark-pool">#</a></h2>
<p>Front running指交易员提前知道有大订单要来，于是价格提前被抬高，因为大家都往能挣钱的地方涌。</p>
<p>Limit order就是front running</p>
<p>如果交易员通过跳价（penny jump）来“front running”大额限价订单，会对市场做市商产生负面影响。如果市场做市商看到交易员跳价并且认为这可能是大额限价订单正在到来的信号，他们可能会相应地调整自己的报价，以适应订单执行后市场价格的变化。这样一来，市场做市商的报价将失去准确性，可能导致市场波动增大，从而影响交易者的投资决策。</p>
<p>跳价（penny jump）：当买方想要购买大量的股票时，他们可能会放置一个大额限价单，这可能会影响到市场价格。因此，为了避免被其他交易者抢先执行，他们可能会将订单价格设定在略高于当前市场价格的水平，以确保他们的订单在市场价格上涨前先被执行。</p>
<p>由于限价单人人都能看到，所以叫做light pool，与之对应的是dark pool。</p>
<p>暗池（Dark Pool）指的是不公开交易数据的交易平台，这些平台允许投资者以匿名方式进行交易，同时也不公开交易价格和数量。这些平台通常由银行、投资机构和证券公司等机构创建，旨在为大型交易提供一种低风险、低成本的交易方式。</p>
<p>与公开市场不同，暗池不会公开所有的订单信息，也不会立即公开交易结果，而是将这些信息保密并推迟披露。这使得交易者可以在不暴露他们的交易策略的情况下进行大额交易，而且交易也不会对市场价格产生影响。可以理解为暗池中的玩家有自己的规则，他们会以市场当前的价格作为参考，买卖双方不想让市场知道有大单子来或者有大单子走，就在暗池中以交易双方谈好的价格和数量进行交易。这也可能导致有些交易者无法了解整个市场的真实情况，进而影响他们的交易决策（通常指散户🤣）。</p>
<p>算法交易者会大量利用暗池。</p>
<h2 id="执行算法">执行算法<a hidden class="anchor" aria-hidden="true" href="#执行算法">#</a></h2>
<p>养老基金或其他大公司通常会进行大体量的交易，他们将这些交易任务交给代理。由于体量非常庞大，一下子全部进入市场会引起很大的价格波动。市价单会产生slippage，限价单会无法执行。因此，代理们会使用执行算法来分割大体量资金并增量执行，目的就是隐藏大订单的存在和最小化价格波动。</p>
<p><strong>执行算法的三种benchmarks</strong></p>
<ul>
<li>VWAP - Volume-Weighted Average Price
<ul>
<li>VWAP是指在一段时间内（通常为一天），基于成交量的加权平均价格，用于衡量一个证券的交易价格表现。</li>
<li>比如在某一天，一只股票上午9:00-11:30交易量是40，下午1:00-3:00交易量是10。那么假如我的执行算法要买入100股，就在第二天上午时间段买入100*(40/(40+10))，下午的时间段买入100*(10/(40+10))</li>
<li>用订单的VWAP和市场的VWAP进行比较，至少达到市场的VWAP水准。</li>
</ul>
</li>
<li>TWAP - Time-Weighted Average Price
<ul>
<li>TWAP算法通过将指定的时间段分成若干个固定时间间隔，然后将交易平均分配在这些时间间隔中，以获得期间的平均价格。</li>
<li>计算方法：（两次交易之间的时间差*每次交易的价格）相加后/总的时间差</li>
<li>用订单的VWAP和市场的TWAP进行比较，至少达到市场的TWAP水准。</li>
</ul>
</li>
<li>Implementation Shortfall
<ul>
<li>一种衡量交易执行质量的方法，用于评估交易策略的有效性。</li>
<li>比较交易成本和买入/卖出股票成本之间的差异</li>
<li>交易成本包括滑点成本、交易费用和市场影响成本等。</li>
<li>买入/卖出股票的成本可以通过VWAP或者TWAP等指标来计算。</li>
<li>IS的值表示交易策略的效果，如果IS值为正，表示交易策略产生了超额收益；如果IS值为负，则表示交易策略产生了亏损。</li>
</ul>
</li>
</ul>
<h1 id="衡量交易策略的表现w4-w5">衡量交易策略的表现（W4-W5）<a hidden class="anchor" aria-hidden="true" href="#衡量交易策略的表现w4-w5">#</a></h1>
<h2 id="收益returns">收益（Returns）<a hidden class="anchor" aria-hidden="true" href="#收益returns">#</a></h2>
<p>收益是判断profit-seeking交易策略的效果的基本要素。</p>
<p>和执行算法（以最低成本执行预先定好的大订单）不同，profit-seeking交易策略目的是产生正的收益。</p>
<h3 id="simple-returns--logarithmic-returns">simple returns &amp; logarithmic returns<a hidden class="anchor" aria-hidden="true" href="#simple-returns--logarithmic-returns">#</a></h3>
<p>假设P(t)和P(t-1)是连续观测的价格时间序列。</p>
<ul>
<li>simple returns: R(t) = (P(t)-P(t-1))/P(t-1) = P(t)/P(t-1) - 1</li>
<li>log returns: R(t) = log(P(t)/P(t-1)) = logP(t) - logP(t-1)</li>
</ul>
<p>PS: 这里的log以e为底，是自然对数。为什么要有log收益？</p>
<ol>
<li>乘法变加法：对数收益将复利收益的乘法运算转换为加法运算，使计算变得更加简单。例如，如果我们有连续的对数收益率 r1、r2 和 r3，那么总收益率就是 r1 + r2 + r3，而不是复利收益的乘法运算。</li>
<li>对称性：对数收益率具有对称性，即正收益和负收益之间的比例关系保持不变。这使得对数收益更易于分析和比较，尤其是在计算投资组合的风险和收益时。</li>
<li>连续时间：在连续时间模型中，使用对数收益率更为方便。这是因为在连续时间中，收益率可以被看作是随时间连续变化的，而对数收益率的加法特性使得在这种情况下的计算更加简单。</li>
<li>数值稳定性：对数收益率提供了更好的数值稳定性。当收益率很小或者数据量很大时，使用对数收益率可以减少浮点数计算中的误差。</li>
<li>正态分布：在许多金融模型中，收益率被假设为正态分布。对数收益率的分布更接近于正态分布，因此在这些模型中更适用。</li>
</ol>
<p>对于一个资产，我们可能会采取以下三种立场</p>
<ul>
<li>long，做多（买入），因为我们期望价格走高。</li>
<li>flat，不买不卖，不确定。</li>
<li>short，做空（卖出），我们预测价格会走低。</li>
</ul>
<p>当我们选择做空，买入时间在卖出时间之后。做空后两种收益比较</p>
<ul>
<li>log return: 做空的log return = - 做多的log return</li>
<li>simple return: 相对于多头的return，空头的return稍微复杂一些：$-R_t/(R_t+1)$</li>
</ul>
<h3 id="roc函数">ROC函数<a hidden class="anchor" aria-hidden="true" href="#roc函数">#</a></h3>
<p>用TTR包中的ROC函数计算return</p>
<p>ROC函数的参数类型可以有两种</p>
<ul>
<li>对于简单收益，就是离散的（discerete）</li>
<li>对于log return，就是连续的（continuous）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-R" data-lang="R"><span style="display:flex;"><span>simple_ret  &lt;- ROC(prices,type=<span style="color:#0ff;font-weight:bold">&#39;discrete&#39;</span>)
</span></span><span style="display:flex;"><span>log_ret     &lt;- ROC(prices,type=<span style="color:#0ff;font-weight:bold">&#39;continuous&#39;</span>)
</span></span></code></pre></div><h2 id="equity-curves">Equity Curves<a hidden class="anchor" aria-hidden="true" href="#equity-curves">#</a></h2>
<p>交易策略盈利能力的时间序列图。它代表了在特定时间内，投资组合价值的变化。equity curves是由投资组合的每个周期结束时的净值（即资产总值减去负债总值）计算得出的。</p>
<h2 id="perfect-returns">Perfect Returns<a hidden class="anchor" aria-hidden="true" href="#perfect-returns">#</a></h2>
<p>这是通过perfect position计算出来的，当市场上升时做多，下降时做空</p>
<h2 id="copycat-strategy">Copycat strategy<a hidden class="anchor" aria-hidden="true" href="#copycat-strategy">#</a></h2>
<p>我们几乎不可能拿到perfect return，没人会准确预测市场。Copycat strategy就是很粗暴的策略。如果当天收盘价&gt;当天开盘价，那么第二天就买入，否则第二天就卖出。</p>
<p>这个策略很蠢，但什么时候会有用？</p>
<ul>
<li>价格连续很多天都朝一个方向移动。</li>
<li>当价格移动方向和前一天不同时，我们不会有太多损失。</li>
</ul>
<p>测试这个策略</p>
<ul>
<li>使用utilities.R中的函数</li>
<li><code>getLogReturns(prices)</code>从调整后的价格计算log return</li>
<li><code>getEquityLog(log_ret,pos)</code>从log return和位置向量上计算一个simple returns equity curve</li>
</ul>
<h2 id="risk-reward-measures">Risk reward measures<a hidden class="anchor" aria-hidden="true" href="#risk-reward-measures">#</a></h2>
<p>盈利能力的衡量标准与风险的衡量标准相结合的绩效衡量标准。</p>
<ul>
<li>Sharpe Ratio</li>
<li>Information Ratio</li>
<li>Sortino Ratio</li>
<li>Maximum drawdown</li>
<li>Calmer Ratio</li>
</ul>
<p>这些比率都在PerformanceAnalytics包中实现。</p>
<h2 id="maximum-drawdown最大回撤">Maximum drawdown最大回撤<a hidden class="anchor" aria-hidden="true" href="#maximum-drawdown最大回撤">#</a></h2>
<p>描述的是投资组合在选定的时间段内可能遭受的最大损失，即从某个时间点的投资组合价值高点到随后的低点之间的资产价值的最大下降幅度。</p>
<p>举个例子，如果你投资的股票在一段时间内从100元上升到200元，然后又降到50元，那么你的最大回撤就是（200-50）/200 = 75%。这说明在最差的情况下，你可能会损失掉75%的投资价值。</p>
<p>最大回撤是一个非常有用的风险度量指标，因为它能够帮助投资者理解其投资组合在未来可能面临的最坏情况。然而，也要注意的是，最大回撤仅仅是过去的历史表现，并不能预测未来。另外，最大回撤也不应该单独使用，应该与其他风险和收益度量一起使用，以全面评估投资组合的性能。</p>
<h2 id="wealth-index财富指数">Wealth Index财富指数<a hidden class="anchor" aria-hidden="true" href="#wealth-index财富指数">#</a></h2>
<h1 id="交易策略-w6-w7">交易策略 (W6-W7)<a hidden class="anchor" aria-hidden="true" href="#交易策略-w6-w7">#</a></h1>
<h2 id="moving-averages">Moving averages<a hidden class="anchor" aria-hidden="true" href="#moving-averages">#</a></h2>
<p>前面提到的copycat策略只是根据前一天的数据来决定第二天的买卖操作。而moving averages策略纳入了更多的历史数据来进行决策。</p>
<p>时间序列过滤器</p>
<ul>
<li><strong>low-pass filter</strong>: 消除短期波动，留下趋势</li>
<li><strong>high-pass filter</strong>: 消除趋势，留下短期波动</li>
</ul>
<p>其中low和high代表的是频率</p>
<p>Causal filters: 目的是在不引入未来信息（未来偏见）的情况下，从历史数据中提取有用的模式或信号。</p>
<ul>
<li>如果其output仅依赖于现在和过去的input，那么就是casual</li>
<li>如果其output依赖了未来的input，那么就是non-casual</li>
</ul>
<p>在策略开发过程中，使用未来信息（在实际交易中是不可获取的）对策略产生不切实际的、过于乐观的效果。通过 Causal Filter，可以确保交易策略的有效性和实际可行性。</p>
<p>Simple &amp; Exponential moving average</p>
<ul>
<li>Simple: 它计算一段时间内（如5天、20天、50天等）数据的算术平均值。简单移动平均线可能受到异常值的影响，因此在处理数据时可能不够灵活。</li>
<li>Exponential: 这是一种加权移动平均线方法，它赋予最近的数据点更高的权重，但权重是按指数衰减的方式分配的。这意味着较早的数据点权重逐渐减小，但永远不会完全消失。指数移动平均线对于跟踪价格趋势非常有用，因为它能平滑短期波动，同时对长期趋势反应灵敏。</li>
</ul>
<h2 id="bollinger-bands超买超卖策略">Bollinger Bands超买超卖策略<a hidden class="anchor" aria-hidden="true" href="#bollinger-bands超买超卖策略">#</a></h2>
<p>Bollinger Bands 是20世纪80年代开发的一种技术分析指标，用于研究金融市场的价格波动。布林带包含三条线，即中间线、上限线和下限线，它们可以帮助交易者识别市场的过度买入或过度卖出现象，从而指导交易决策。</p>
<p>均值回归交易策略就使用了布林带</p>
<ul>
<li>当它们暗示市场超卖(oversold)时买入</li>
<li>当它们暗示市场超买(overbought)时卖出</li>
</ul>
<p>布林带的三条线</p>
<ul>
<li>中间线（Middle Band）：通常为价格的简单移动平均（SMA），常见的周期设置为20天。</li>
<li>上限线（Upper Band）：上限线是中间线加上一个标准差乘以系数（通常为2）。标准差是一个统计概念，用于衡量数据的波动程度。这里的系数是用于调整带宽的一个参数，通常设为2。</li>
<li>下限线（Lower Band）：下限线是中间线减去一个标准差乘以系数（通常为2）。</li>
</ul>
<p>布林带的宽度会随着价格波动的加大而加大，反之则缩小。布林带的宽度的变化可以用来衡量市场的波动性。当布林带变窄时，表示市场波动较小，可能预示着即将出现的大幅波动（突破）。当布林带变宽时，表示市场波动加大，可能暗示着趋势的持续。</p>
<p>使用AAPL股票数据，应用布林带技术指标，并选择了2008年。图表的类型被设置为线形图（type=&lsquo;l&rsquo;）。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-R" data-lang="R"><span style="display:flex;"><span>&gt; library(quantmod)
</span></span><span style="display:flex;"><span>&gt; getSymbols(<span style="color:#0ff;font-weight:bold">&#39;AAPL&#39;</span>)
</span></span><span style="display:flex;"><span>&gt; taString &lt;- <span style="color:#0ff;font-weight:bold">&#39;addBBands();addBBands(draw=&#34;p&#34;)&#39;</span>
</span></span><span style="display:flex;"><span>&gt; chartSeries(AAPL,TA=taString,subset=<span style="color:#0ff;font-weight:bold">&#39;2008&#39;</span>,type=<span style="color:#0ff;font-weight:bold">&#39;l&#39;</span>)
</span></span></code></pre></div><p>布林带的参数 <code>bbands&lt;-BBands(prices, n=n, sd=sd)</code>，其中n表示计算中轨线的周期为n天，sd表示上下轨道线相对于中轨线的标准差倍数为sd（不是标准差，是标准差的倍数！）。</p>
<h2 id="path-independence--dependence">Path independence &amp; dependence<a hidden class="anchor" aria-hidden="true" href="#path-independence--dependence">#</a></h2>
<p>如果一个交易策略不依赖过去的决策，那么这种决策被称为路径无关，path independence.</p>
<p>布林带策略就是典型的路径无关交易策略</p>
<p>路径无关实际上是一种很严格的限制，现在大部分的交易策略都是路径相关的。</p>
<p>许多策略的构建都需要路径依赖，例如一些特殊的卖空条件：</p>
<ul>
<li>Holding period (持有时间)</li>
<li>profit target (盈利目标)</li>
<li>stop loss (止损点)</li>
</ul>
<h2 id="slippage">Slippage<a hidden class="anchor" aria-hidden="true" href="#slippage">#</a></h2>
<p>之前提到过，就是量很大没有单子能一下接的住，那么卖出的价格就会偏低（买入的价格会偏高）。这种情况通常在市场波动较大或流动性较低的情况下发生。在策略回测中，为了保守起见，我们通常假设滑点对交易者是不利的。</p>
<p>在策略回测时采用这种假设滑点为负的标准方法是在策略回测中常用的一种方法。这样可以使回测结果更加保守，从而避免在实际交易中因对策略过于乐观而导致的损失。</p>
<p>所以在构建交易模型时要估计实际成交价格与预期成交价格之间的差异，这叫做模拟滑点。</p>
<ol>
<li>交易策略的特点：了解策略在哪些市场环境中进行交易。如果其他市场参与者采取类似策略，滑点可能会变得更糟糕。例如：
<ul>
<li>如果在涨势中买入，可能会出现负滑点，因为许多交易者可能在涨势中买入，从而推高价格。</li>
<li>如果在抛售过程中买入，可能会出现正滑点，因为在供应过剩的情况下，你可能可以以较低的价格买入。</li>
</ul>
</li>
<li>特定市场的特点：考虑你所交易的特定市场，因为不同市场的流动性和波动性可能会影响滑点。要考虑的一些因素包括：
<ul>
<li>被交易的资产：某些资产（如流动性较低的股票或加密货币）可能比流动性较强的资产（如主要货币对或大盘股）具有更高的滑点。</li>
<li>市场交易时间：在流动性较低的时段（例如，非正常交易时间）进行交易可能导致较高的滑点。</li>
<li>新闻与事件：重大新闻事件或经济数据发布可能导致波动性突然增加，从而导致滑点增加。</li>
</ul>
</li>
<li>数据可用性：为了准确地模拟滑点，理想情况下需要访问高质量数据，包括：
<ul>
<li>订单簿数据：此类数据提供了不同价格和数量的信息，有助于更准确地估计滑点。</li>
<li>成交量数据：可以帮助了解市场的流动性状况，从而更好地预测滑点。</li>
</ul>
</li>
</ol>
<h2 id="均值回归策略">均值回归策略<a hidden class="anchor" aria-hidden="true" href="#均值回归策略">#</a></h2>
<p>2类策略</p>
<ol>
<li>mean reversion/contrarian/overbought-oversold 均值回归/反向/超买超卖</li>
<li>trend following / momentum</li>
</ol>
<p>第一类策略是基于市场可能出现错误定价的观点。这些策略在实施时可能会有所不同。</p>
<ul>
<li>均值回归策略认为价格会在一段时间内回归到其长期平均值。</li>
<li>Contrarian策略是投资者相信市场可能对某些资产的价格作出错误判断，因此会采取与大多数人相反的交易行为。他们试图利用市场的过度反应来获得利润。</li>
<li>超买超卖策略则关注市场中的短期波动，试图捕捉价格在达到极端水平后可能出现的反转。</li>
<li>统计套利（Statistical Arbitrage）
<ul>
<li>这是一种复杂的量化投资策略，利用统计方法预测和利用金融市场的价格偏差。</li>
<li>基本思路是建立一个模型来识别价格偏离其预期值的情况，然后利用这种偏离进行交易，以期待价格回归预期值。</li>
</ul>
</li>
<li>配对交易（Pairs Trading）
<ul>
<li>配对交易是统计套利的一种特殊形式。它基于两只或更多相关资产（通常是股票）之间的历史价格关系。</li>
<li>当这些资产的价格关系偏离历史正常水平时，交易员会买入价格偏低的资产并卖出价格偏高的资产，等待价格回归正常关系时再平仓，从而获得利润。</li>
<li>配对交易的难度在于找到正确的配对资产，需要对行业和公司有深入的理解，并且需要足够的数据来支持策略。</li>
</ul>
</li>
</ul>
<p>PS: 统计套利和配对交易都属于均值回归策略的一种，这些策略基于一个假设：市场价格或价格差（在配对交易中）会回归到它们的历史平均值。</p>
<p>协整理论（Cointegration）</p>
<ul>
<li>用于描述两个或更多个时间序列之间的长期均衡关系。</li>
<li>在金融中，协整理论的应用主要体现在配对交易或其他统计套利策略中。如果两只股票的价格是协整的，那么他们的价格将保持一定的长期关系。如果这种关系暂时偏离了历史正常水平，那么交易员可以预期它会在未来回归到这种关系，并据此进行交易。</li>
<li>例如，如果股票A和股票B是协整的，并且A相对于B暂时过高，那么交易员可能会卖出A并买入B，等待价格回归到他们的长期关系。</li>
</ul>
<p>隐式仓位比率（Implied Position Ratio）/对冲比率（Hedge Ratio）</p>
<ul>
<li>这个比率描述了需要用一个资产去对冲另一个资产风险的数量。</li>
<li>这种策略的关键在于，两个资产的价格变化是相关的。两个资产的价格变化也会在很短的时间内变得不再相关，所以要密切关注。</li>
<li>对冲比率通常通过回归分析来确定。</li>
<li>假设有两只股票，苹果（AAPL）和微软（MSFT），通过回归分析，我们发现每当苹果股价变动1美元，微软股价通常变动0.5美元，那么对冲比率就是0.5。这意味着，如果我们持有1美元的苹果股票，可以通过卖出0.5美元的微软股票来对冲我们的苹果股票风险。</li>
<li>在配对交易或统计套利策略中，投资者并不是因为预测到某一支股票会亏损才选择持有它，而是因为他们预测到两支股票之间的价格差距会收敛。</li>
<li>假设苹果（AAPL）和微软（MSFT）的股票价格有一定的相关性，而现在这两者的价格差距大于历史平均水平。也就是说，相对于微软，苹果的股票被低估了。在这种情况下，投资者可能会购买苹果股票，并同时卖空微软股票，希望当两者的价格差距回归到历史正常水平时获利。</li>
<li>在这个过程中，即使苹果的股票价格下跌，如果微软的股票价格下跌得更多（这是有可能的，因为两者的股票价格有相关性），那么投资者仍然有可能获利，因为他们是从两者的价格差距收敛中获利，而不是从单一股票的涨跌中获利。</li>
<li>上面的话使我对于对冲的理解更加深刻👆</li>
</ul>
<p>spread通常指的是两个或更多相关资产之间的价格差异。根据资产的种类和交易的时间，spread可以在很多不同的情况下建立。以下是一些常见的例子：</p>
<ul>
<li>在同一个商品的不同月份之间。例如可以在3月份的原油期货和5月份的原油期货之间建立一个spread。这是一种常见的期货交易策略，投资者预期同一商品在不同交割月份的价格会有一定的变化。<strong>(called an interdelivery spread/ calendar spread)</strong></li>
<li>在同一个或相关商品之间建立，通常是在同一个月份。例如，在黄金和白银之间建立一个spread。这种策略通常用于套利交易，投资者预期两种相关商品的价格差将回归到其历史平均水平。<strong>(intercommodity spread)</strong></li>
<li>在在两个不同的交易所上交易的同一种或相关商品之间建立。例如，可以在纽约商品交易所交易的黄金期货和伦敦金属交易所交易的黄金期货之间建立一个spread。这种策略通常用于利用不同市场之间的价格差异进行套利。<strong>(Intermarket Spread)</strong></li>
<li>在两只股票之间建立的，这两只股票通常是在同一行业或市场中，有相似的商业模式或经济影响因素。例如，可以在苹果（AAPL）和微软（MSFT）之间建立一个spread。这种策略通常用于利用两只股票价格的相对波动进行套利。<strong>(Pairs Trading)</strong></li>
</ul>
<p>第二类策略是基于资产价格行为的一种方式。</p>
<ul>
<li>趋势追踪策略是一种基于历史价格趋势预测未来价格趋势的策略。趋势追踪者认为市场价格展现出一定的动量或趋势，并会尝试利用这些趋势进行投资。当资产价格显现出上涨趋势时，趋势追踪者将买入该资产；当资产价格显现出下跌趋势时，趋势追踪者将卖出或做空该资产。</li>
<li>动量投资策略是一种基于资产近期价格表现预测未来价格表现的策略。动量投资者认为过去一段时间内表现较好的资产将在未来继续表现优秀，而表现较差的资产将在未来继续表现疲弱。因此，他们会购买近期表现优秀的资产，并卖出或做空近期表现疲弱的资产。</li>
</ul>
<p>二者区别：这两种策略都是试图从市场趋势和动量中获利，但趋势追踪更注重长期趋势，而动量投资更注重短期价格表现。</p>
<p>跟踪止损和盈利目标</p>
<ul>
<li>动量策略通常使用止损（Stop Loss）作为退出策略，而均值回归策略通常使用利润目标（Profit Target）作为退出策略。</li>
<li>Stop Loss：这是一种预先设定的订单，旨在限制投资者可能遭受的损失。这通常在价格向对投资者不利的方向移动时触发。在动量策略中，止损订单可以帮助投资者在市场反转时保护其资本。</li>
<li>Profit Target：这是预先设定的价格级别，一旦达到该级别，投资者将关闭位置以获取利润。在均值回归策略中，利润目标可以帮助投资者在价格回归到其均值时锁定利润。</li>
<li>Trailing Stop Loss：这是一种动态的止损策略。当交易价格向有利的方向移动时，跟踪止损将跟随市场价格移动，从而允许投资者在保护其资本的同时，捕获更多的利润。跟踪止损通常相对于交易的最佳价格而不是入场价格进行设置。</li>
</ul>
<h1 id="回溯测试优化以及交叉验证w7-w9">回溯测试，优化以及交叉验证(W7-W9)<a hidden class="anchor" aria-hidden="true" href="#回溯测试优化以及交叉验证w7-w9">#</a></h1>
<h2 id="交叉验证">交叉验证<a hidden class="anchor" aria-hidden="true" href="#交叉验证">#</a></h2>
<p>想知道模型在未来交易中表现怎么样，要用到交叉验证。统计学中交叉验证的概念：把训练的模型一般化到不可见的数据集中表现怎么样。交叉验证降低了data-snooping bias（数据窥探风险）</p>
<h3 id="in-sample和out-sample-test">In-sample和out-sample test<a hidden class="anchor" aria-hidden="true" href="#in-sample和out-sample-test">#</a></h3>
<p>in-sample就是训练集，out-sample就是测试集</p>
<p>作用</p>
<ul>
<li>防止过拟合</li>
<li>评判在为未来表现的重要指标</li>
</ul>
<p>注意：out-sample中性能下降是很正常的现象</p>
<h3 id="rsi-strategy">RSI strategy<a hidden class="anchor" aria-hidden="true" href="#rsi-strategy">#</a></h3>
<p>RSI(Relative strength Index)相对强度指数。这是TTR包中的一个标准的指标。这个指标返回一个0-100之间的值，值越高表明市场最近正在上涨趋势，反之亦然。</p>
<h3 id="bias">Bias<a hidden class="anchor" aria-hidden="true" href="#bias">#</a></h3>
<ul>
<li>Look-ahead Bias: 这种偏误发生在你的模型或策略使用了在实际情况下不可能在当前时点获取的信息。例如，假设你在模型中使用了明天的股价作为今天投资决策的依据，这就产生了向前偏误。</li>
<li>Survivorship Bias: 生存偏误发生在，当你的样本只包含“生存者”（即，成功或者持续存在的例子），而忽视了“非生存者”（即，失败或者已经不存在的例子）。例如，在股票市场研究中，如果你只研究当前仍在交易的公司，而忽视了已经破产或被收购的公司，那么你的研究就可能存在生存偏误。</li>
<li>Data-snooping Bias: 这种偏误出现在过度拟合过去的数据，试图找出符合这些数据的模式或策略，但这些模式或策略在未来可能并不适用。这种过度拟合可能导致过于乐观的策略性能预期。</li>
<li>Time period Bias: 这种偏误出现在，当策略的性能依赖于选择的特定时间段时。例如，如果你的策略在牛市中表现出色，但在熊市中表现不佳，那么你就可能过于依赖特定的时间段（例如，仅在牛市中）进行策略测试。</li>
<li>Confirmation Bias: 确认偏误是一种心理学现象，当人们倾向于寻找和关注那些符合自己预设观点的信息，而忽视或者低估那些与自己观点相悖的信息。在交易策略的开发中，如果你只关注那些支持你的策略的测试结果，而忽视了那些反对你的策略的结果，那么你可能就会陷入确认偏误。</li>
</ul>
<p>交叉验证可以避免Data-snooping Bias。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://martinspace.top/zh/tags/finance/">Finance</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://martinspace.top/zh/canonical-coins/">
    <span class="title">« 上一页</span>
    <br>
    <span>Canonical coins system</span>
  </a>
  <a class="next" href="https://martinspace.top/zh/comp202/">
    <span class="title">下一页 »</span>
    <br>
    <span>算法(COMP202)</span>
  </a>
</nav>
<script src="https://utteranc.es/client.js"
        repo="oudushu/utterances"
        issue-term="title"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>



  </footer><script src="https://utteranc.es/client.js"
    repo="MartinRepo/utterancesInblog"
    issue-term="pathname"
    label="Comment"
    theme="preferred-color-scheme"
    crossorigin="anonymous"
    async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://martinspace.top/zh/">Martin&#39;s space</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
        <br> 
        
        <a href="https://beian.miit.gov.cn" rel="noopener" target="_blank">辽 ICP 备 2022011010 号 -1</a>
    </span>
    
    <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv">
        被访问了<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
        迎接了<span id="busuanzi_value_site_uv"></span>位客人
    </span>
    </div>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
